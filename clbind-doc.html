<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-07-05 Mon 13:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Exposing C++ Libraries with clbind</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/><link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script><script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script><script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="top-menu">
<ul>
<li><a href="index.html">Clasp</a>
<ul>
<li><a href="news.html">News</a></li>
<li><a href="features.html">Features</a></li>
<li><a href="download.html">Download</a></li>
</ul></li>
<li><a href="index.html">Doc</a>
<ul>
<li><a href="license.html">License</a></li>
<li><a href="building.html">Building Clasp</a></li>
<li><a href="clbind-doc.html">Exposing C++ Libraries</a></li>
</ul></li>
<li><a href="index.html">Misc</a>
<ul>
<li><a href="community.html">Community</a></li>
<li><a href="projects.html">Projects</a></li>
<li><a href="media.html">Media</a></li>
<li><a href="acknowlegements.html">Acknowledgements</a></li>
</ul></li>
</ul>
</div>
</div>
<div id="content">
<h1 class="title">Exposing C++ Libraries with clbind</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3586371">1. General information</a></li>
<li><a href="#orgb6c80f4">2. Integrating with the clasp build system</a></li>
<li><a href="#org5cefcdd">3. Structure of a Binding</a></li>
<li><a href="#org01a8faa">4. Include Files</a></li>
<li><a href="#orge2c78e7">5. Exposing Functions</a>
<ul>
<li><a href="#org42a6057">5.1. Overloaded Functions</a></li>
</ul>
</li>
<li><a href="#org9fb59d2">6. Exposing Classes</a>
<ul>
<li><a href="#org6edc150">6.1. Inheritance</a></li>
<li><a href="#org6de1ee1">6.2. Constructors</a></li>
<li><a href="#org2460f46">6.3. Member Functions</a></li>
<li><a href="#org71ee102">6.4. Static Member Function</a></li>
<li><a href="#org8d2f92a">6.5. Public Member Variables</a></li>
<li><a href="#org8ac580a">6.6. Derivable classes</a></li>
</ul>
</li>
<li><a href="#org6dd4a95">7. Exposing Enums</a></li>
<li><a href="#orgffc8a91">8. Translators</a>
<ul>
<li><a href="#org3ce892d">8.1. Translation from C++ objects to Common Lisp objects</a></li>
<li><a href="#org647a4ab">8.2. Translation from Common Lisp objects to C++ objects</a>
<ul>
<li><a href="#org2cc66f3">8.2.1. Advanced from_object translators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7ff9b4d">9. Policies</a>
<ul>
<li><a href="#orga7625ea">9.1. pureOutValue&lt;N&gt;</a></li>
<li><a href="#org35af480">9.2. outValue&lt;N&gt;</a></li>
<li><a href="#org9bdc578">9.3. adopt&lt;n&gt;</a></li>
</ul>
</li>
<li><a href="#org084cfe7">10. Lispification</a>
<ul>
<li><a href="#org2b8ded0">10.1. Camel case</a></li>
<li><a href="#org06fd9ee">10.2. Underscores become hyphens</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org3586371" class="outline-2">
<h2 id="org3586371"><span class="section-number-2">1</span> General information</h2>
<div class="outline-text-2" id="text-1">
<p>
clbind is based on luabind with some ideas borrowed from pybind11 and boost::python.
</p>
</div>
</div>

<div id="outline-container-orgb6c80f4" class="outline-2">
<h2 id="orgb6c80f4"><span class="section-number-2">2</span> Integrating with the clasp build system</h2>
<div class="outline-text-2" id="text-2">
<p>
Integrating an external library, or your own C++ code, into Clasp involves integrating into Clasp's build system.
Clasp build system is built on the <a href="http://waf.io">waf</a> build system.
</p>

<p>
All you need to do is clone your extension into the clasp/extensions directory and create a <code>wscript</code> file in each directory of your extension.
</p>

<p>
For instance - suppose you have the following directory structure.
</p>

<div class="org-src-container">
<pre class="src src-sh">clasp
├── wscript                 # Provided by Clasp
└── extensions
    ├── wscript             # Provided by Clasp
    └── my-demo
	└── src
	    └── my-demo.cc
</pre>
</div>

<p>
The my-demo.cc file would look like&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-C++">#include &lt;stdio.h&gt;
#include &lt;clasp/clasp.h&gt;

void my_func()
{
  printf("This is not the greatest function in the world. It's just a tribute!\n");
}

PACKAGE_USE("COMMON-LISP");
PACKAGE_NICKNAME("MD");
NAMESPACE_PACKAGE_ASSOCIATION(hw,HWPkg,"MY-DEMO");

namespace md {
CL_EXPOSE
void my_demo_startup() {
  printf("Entered %s:%d:%s\n", __FILE__, __LINE__, __FUNCTION__ );
  using namespace clbind;
  package_ sc(HWPkg);
  sc.def("my-func", &amp;my_func);
}
</pre>
</div>


<p>
In the extensions/my-demo directory you need to add a <code>wscript</code> file that looks like below.
It looks a bit daunting and we will fill in more information in the future as users request more information.
For now these functions are required to integrate with the clasp waf build system.
</p>

<div class="org-src-container">
<pre class="src src-Python">
from wscript_utils import *

def analyze_clasp(cfg):
    pass

def options(cfg):
    pass

def configure(cfg):
    cfg.extensions_startup_scripts.append("demo-startup.lisp") # (1)
    pass

def build(bld):
    bld.recurse("src")          # (2)

def build3(bld):
    pass

def build4(bld):
    pass

</pre>
</div>

<ol class="org-ol">
<li>Add a lisp startup script that is evaluated once clasp has finished initializing.</li>
</ol>
<p>
This allows the programmer to add lisp code to clasp.
</p>
<ol class="org-ol">
<li>The bld.recurse("src") call causes waf to recurse into the my-demo/src directory.  Add one of these calls for every source directory that you want to integrate into Clasp.</li>
</ol>


<p>
Next you need a wscript file in the src directory - this one is simpler&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-Python">
def configure(cfg):
    pass

def build(bld):
    bld.extensions_source_files.append(bld.path.find_node("my-demo.cc"))    # (1)

</pre>
</div>

<ol class="org-ol">
<li>Add one of these lines for every source file that you want to build.  Alternatively you can put the source files in a list and loop over then calling this function. This adds your extension C++ source files to the list of C++ files that clasp builds when it builds itself.</li>
</ol>

<p>
Once these files are added your directory structure will look like&#x2026;
</p>
<div class="org-src-container">
<pre class="src src-sh">clasp
├── wscript
└── extensions
    ├── wscript
    └── my-demo
	├── wscript         # Added above
	└── src
	    ├── wscript     # Added above
	    └── my-demo.cc
</pre>
</div>


<p>
That's it - once you have added these files you can go into the top level clasp directory and type <code>./waf build_dboehm</code> and clasp will build and incorporate all of the extensions in the clasp/extensions directory.
</p>
</div>
</div>



<div id="outline-container-org5cefcdd" class="outline-2">
<h2 id="org5cefcdd"><span class="section-number-2">3</span> Structure of a Binding</h2>
<div class="outline-text-2" id="text-3">
<p>
Clasp is able to load C++ libraries and expose functions, classes, methods and enums to Clasp Common Lisp.
Clasp needs a function that it can call at startup to expose these library members - it uses the CL_EXPOSE c-preprocessor macro to identify these startup functions.
Within this function, packages can be declared and functions, classes, methods and enums can be added to the package and they will then
automatically be available within Clasp.
</p>

<p>
Thus, code should include a section like this:
</p>


<div class="org-src-container">
<pre class="src src-C++">
PACKAGE_USE("COMMON-LISP");                             // (1)
PACKAGE_NICKNAME("HW");                                 // (2)
NAMESPACE_PACKAGE_ASSOCIATION(hw,HWPkg,"HELLO-WORLD");  // (3)

namespace hw {                                          // (4)
CL_EXPOSE                                               // (5)
void hello_world_startup () {                           // (6)
  using namespace clbind;                               // (7)
  package_ sc(HWPkg);                                   // (8)
  sc.def("hello-world", &amp;helloWorld,                    // (9)
      "The classic! Print Hello world"_doc );          
}
</pre>
</div>

<ol class="org-ol">
<li>Declaring a package is done in reverse order here - declare that the COMMON-LISP package will be used by the HELLO-WORLD package.</li>
<li>Declare a nickname "HW" for the package declaration that will follow. PACKAGE_NICKNAME is a cpp macro that will be scraped by the clasp <a href="scraper.html">scraper</a>.</li>
<li>Declare the package "HELLO-WORLD" and create a global variable that will store its name <code>HWPkg</code> and associate it with a C++ namespace <code>hw</code>. This will be picked up by the <a href="scraper.html">scraper</a>.</li>
<li>To avoid symbol clashes in C++ - put your code in a unique C++ namespace.</li>
<li>The <code>CL_EXPOSE</code> c-preprocessor macro is used to identify the following function as one that exposes functionality to Clasp.</li>
<li>The name of the function is arbitrary.</li>
<li>For convenience we use the clbind package - but you can prefix all clbind identifiers with the clbind:: namespace.</li>
<li>Bind the <code>sc</code> local variable to the package named "HELLO-WORLD".</li>
<li>Expose a function, provide the name, a pointer to the function and other optional arguments.</li>
</ol>

<p>
After building clasp with this extension added the user can access it so&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-Lisp">COMMON-LISP-USER&gt; (hw:hello-world)
Hello World
This is C++ code being invoked from Clasp Common Lisp
COMMON-LISP-USER&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org01a8faa" class="outline-2">
<h2 id="org01a8faa"><span class="section-number-2">4</span> Include Files</h2>
<div class="outline-text-2" id="text-4">
<p>
Compiling the binding requires the inclusion of one header file <code>clasp/clasp.h</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++">#include &lt;clasp/clasp.h&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge2c78e7" class="outline-2">
<h2 id="orge2c78e7"><span class="section-number-2">5</span> Exposing Functions</h2>
<div class="outline-text-2" id="text-5">
<p>
Exposing functions is done via the function <code>def</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">template &lt;typename F, class... Policies&gt;
scope def(char     const* name,
	  F               f,
	  Policies... policies )
</pre>
</div>
<p>
In this function
</p>
<dl class="org-dl">
<dt>name</dt><dd>is the name that the function will have in clasp. It is automatically <a href="#org084cfe7">lispified</a>, i.e. a name  with camel-casing is converted to a downcase name with dashes in between. Using this automatic lispification is optional, and it can be useful to use names following lisp conventions, so that a reader can immediately see how the respective lisp function is called.</dd>
<dt>f</dt><dd>is the function pointer to the c++ function.</dd>
<dt>policies</dt><dd>Gives additional information about how to handle some parameters (see <a href="#org7ff9b4d">Policies</a>).</dd>
</dl>

<p>
Suppose we have a C++ function 
</p>
<div class="org-src-container">
<pre class="src src-C++">double addThreeNumbers(double x, double y, double z) {
    return x + y + z;
}
</pre>
</div>

<p>
A complete binding could look like this (only the first two parameters are required) 
</p>
<div class="org-src-container">
<pre class="src src-C++">PACKAGE_NICKNAME("HW");
NAMESPACE_PACKAGE_ASSOCIATION(hw,HWPkg,"HELLO-WORLD");

SYMBOL_EXPORT_SC_(HWPkg,STARcolorTranslatorSTAR);
CLBIND_TRANSLATE_SYMBOL_TO_ENUM(ColorEnum, hw::_sym_STARcolorTranslatorSTAR );

namespace hw {
CL_EXPOSE
void hello_world_startup() {
  using namespace clbind;
  package_ sc(HWPkg);
  sc.def("hello-world",&amp;helloWorld,
	  "The classic! Print Hello-world"_doc);
  sc.def("addThreeNumbers",&amp;addThreeNumbers,                       // (1)
	 "(x cl:&amp;optional (y 0.0) (z 0.0))"_ll,                    // (2)
	  "Add three numbers and return the result"_doc );         // (3)
</pre>
</div>

<ol class="org-ol">
<li>Only the first two arguments are required, the name of the function that is <a href="#org084cfe7">lispified</a> and a pointer to the function.</li>
<li>The lambda list for the function is provided in a string with the <code>_ll</code> suffix.</li>
<li>A documentation string is provided with the <code>_doc</code> suffix.</li>
</ol>

<p>
From clasp, this function can be called with 
<code>(hw:add-three-numbers 1)</code> or <code>(hw:add-three-numbers 1 2)</code> or <code>(hw:add-three-numbers 1 2 3)</code>.
The C++ function is called as <code>addThreeNumbers(1,0,0)</code>, <code>addThreeNumbers(1,2,0)</code> and <code>addThreeNumbers(1,2,3)</code>, respectively.
</p>

<p>
The lambda list and documentation string can be obtained using the Common Lisp function <code>describe</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
COMMON-LISP-USER&gt; (describe 'hw:add-three-numbers)

HELLO-WORLD:ADD-THREE-NUMBERS - external symbol in HELLO-WORLD package
-----------------------------------------------------------------------------
HELLO-WORLD:ADD-THREE-NUMBERS                                      [Function]
Documentation: "Add three numbers and return the result"
Arguments:     (HELLO-WORLD::X &amp;OPTIONAL (HELLO-WORLD::Y 2.0) (HELLO-WORLD::Z 3.0))
Source:        #P"=external="
-----------------------------------------------------------------------------

</pre>
</div>
</div>

<div id="outline-container-org42a6057" class="outline-3">
<h3 id="org42a6057"><span class="section-number-3">5.1</span> Overloaded Functions</h3>
<div class="outline-text-3" id="text-5-1">
<p>
To expose overloaded functions, you have to cast the function pointer to the correct signature. 
Suppose the function from the previous example would be overloaded. It would then need an exposure such as below.
</p>

<div class="org-src-container">
<pre class="src src-C++">def("addThreeNumbers-double", (double(*)(double, double, double)) &amp;addThreeNumbers),
</pre>
</div>

<p>
It is important that every function have a unique name - similar to name mangling in C++.
The convention we adopt in Clasp is to append type names to the original name.
</p>
</div>
</div>
</div>


<div id="outline-container-org9fb59d2" class="outline-2">
<h2 id="org9fb59d2"><span class="section-number-2">6</span> Exposing Classes</h2>
<div class="outline-text-2" id="text-6">
<p>
Exposing a class is done via the class <code>class_</code>:
</p>

<p>
For example - we have the class DoubleVector below:
</p>
<div class="org-src-container">
<pre class="src src-C++">class DoubleVector {
private:
  vector&lt;double&gt;      values;
public:
  DoubleVector(int sz) {this-&gt;values.resize(sz);};
  DoubleVector(const vector&lt;double&gt;&amp; arg) {
    this-&gt;fill(arg);
  }
//...
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++">PACKAGE_USE("COMMON-LISP");
PACKAGE_NICKNAME("DV");
NAMESPACE_PACKAGE_ASSOCIATION(hw,HWPkg,"DOUBLE-VECTOR");

namespace dv {
CL_EXPOSE
void double_vector_startup() {
  using namespace clbind;
  package_ s("DV");
  class_&lt;DoubleVector&gt;(s,"double-vector" )
//...

</pre>
</div>

<p>
Creates a Binding to the C++ class <code>DoubleVector</code>, with the name <code>dv:double-vector</code> in lisp.
This does not automatically creates a binding to the default constructor - use def_constructor for constructors.
</p>
</div>

<div id="outline-container-org6edc150" class="outline-3">
<h3 id="org6edc150"><span class="section-number-3">6.1</span> Inheritance</h3>
<div class="outline-text-3" id="text-6-1">
<p>
clbind can handle member functions of derived classes correctly, providing that they are exposed.
To expose the inheritance structure of C++ classes, expose the base class, and use the following format for the derived class:
</p>
<div class="org-src-container">
<pre class="src src-C++">class_&lt;CppDerivedClassName, CppBaseClassName&gt;("lisp-class-name")
</pre>
</div>
<p>
If multiple inheritance brings in several base classes, use the following format:
</p>
<div class="org-src-container">
<pre class="src src-C++">class_&lt;CppDerivedClassName, bases&lt;CppBaseClassName1, CppBaseClassName2&gt;&gt;("lisp-class-name")
</pre>
</div>
<p>
If a base class is a pure virtual class, i.e. it has only pure virtual functions or its constructor is private, make sure to use the <code>no_default_constructor</code> option when exposing the base class, otherwise you will get a compilation error.
</p>
</div>
</div>

<div id="outline-container-org6de1ee1" class="outline-3">
<h3 id="org6de1ee1"><span class="section-number-3">6.2</span> Constructors</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Add constructors to exposed classes with the function <code>def_constructor</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">template&lt;typename... Types, typename... Policies&gt;
class_&amp; def_constructor(const string&amp;         name,
			constructor&lt;Types...&gt; sig,
			Policies...           policies)
</pre>
</div>
<p>
In this function
</p>
<dl class="org-dl">
<dt>name</dt><dd>is the name of the constructor that will be visible in clasp. Again, it will be lispified.</dd>
<dt>sig</dt><dd>is the parameter signature of the C++ constructor. Use a comma-separated parameter-list list in the form <code>constructor&lt;parameter-list&gt;()</code> of all the types used as parameters in the constructor you want to expose.</dd>
<dt>policies</dt><dd>Optional parameters, explained in <a href="#orge2c78e7">Exposing Functions</a></dd>
</dl>
</div>
</div>

<div id="outline-container-org2460f46" class="outline-3">
<h3 id="org2460f46"><span class="section-number-3">6.3</span> Member Functions</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Exposing member functions is similar to exposing free functions. Call the <code>class_</code> member function <code>def</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++">template&lt;class F, class... Policies&gt;
class_&amp; def(char const*       name, 
	    F                 fn, 
	    Policies...       policies )
</pre>
</div>
<p>
Thus exposing a member function is not different from <a href="#orge2c78e7">exposing free functions</a>, and the same arguments apply.
The exception to this rule is the lambda-list (arguments), which always requires <code>self</code> as its first parameter, which becomes the <code>this</code> argument within the method.
</p>


<div class="org-src-container">
<pre class="src src-C++">namespace dv {
CL_EXPOSE
void double_vector_startup() {
  using namespace clbind;
  package_ s("DV");
  class_&lt;DoubleVector&gt;(s,"double-vector" )
    .   def_constructor("make-double-vector-with-size",constructor&lt;int&gt;())
    .   def_constructor("make-double-vector-with-values",constructor&lt;const vector&lt;double&gt;&amp;&gt;())
    .   def("fill",&amp;DoubleVector::fill)
    .   def("add",&amp;DoubleVector::add)
    .   def("dot",&amp;DoubleVector::dot)
    .   def("at",&amp;DoubleVector::at)
    .   def("dump",&amp;DoubleVector::dump);

}
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org71ee102" class="outline-3">
<h3 id="org71ee102"><span class="section-number-3">6.4</span> Static Member Function</h3>
<div class="outline-text-3" id="text-6-4">
<p>
As Common Lisp does not have the notion of static member functions, exposing them is similar to <a href="#orge2c78e7">exposing free functions</a>.
</p>
</div>
</div>

<div id="outline-container-org8d2f92a" class="outline-3">
<h3 id="org8d2f92a"><span class="section-number-3">6.5</span> Public Member Variables</h3>
<div class="outline-text-3" id="text-6-5">
<p>
Exposing public member variables works similar to exposing member functions. 
</p>
</div>
</div>

<div id="outline-container-org8ac580a" class="outline-3">
<h3 id="org8ac580a"><span class="section-number-3">6.6</span> Derivable classes</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Some C++ libraries provide base classes that the library user is meant to subclass to add additional application specific functionality.
For this situation Clasp allows one to create classes in Common Lisp that derive from these C++ classes and implement methods that get called from
both C++ and Common Lisp code.
</p>

<p>
An example of this is within Clasp itself - where Clasp exposes the Clang ASTMatcher library.
Clasp exposes a facility of the Clang ASTMatcher library that evaluates callbacks on Clang C++ Abstract Syntax Tree nodes.
In the place of <code>class_</code> use <code>derivable_class_</code> and provide two class template arguments.
The first template argument is a class that needs to be provided to clbind and is shown below (in this case DerivableMatchCallback).  
The second template argument is the original library class that is to be subclassed (in this case clang::ast_matchers::MatchFinder::MatchCallback).
</p>

<div class="org-src-container">
<pre class="src src-C++">derivable_class_&lt;DerivableMatchCallback, clang::ast_matchers::MatchFinder::MatchCallback&gt; cl_bc(m,"MatchCallback",create_default_constructor);
cl_bc.def("run", &amp;DerivableMatchCallback::default_run)
    .def("onStartOfTranslationUnit", &amp;DerivableMatchCallback::default_onStartOfTranslationUnit)
    .def("onEndOfTranslationUnit", &amp;DerivableMatchCallback::default_onEndOfTranslationUnit);
</pre>
</div>

<p>
The DerivableMatchCallback must be defined before the derivable_class_ declaration above.
</p>

<div class="org-src-container">
<pre class="src src-C++">namespace asttooling {
  class DerivableMatchCallback;                        // (1)
};

template &lt;&gt;                                            // (2)
struct gctools::GCInfo&lt;asttooling::DerivableMatchCallback&gt; {
  static bool constexpr NeedsInitialization = false;
  static bool constexpr NeedsFinalization = false;
  static GCInfo_policy constexpr Policy = unmanaged;   // (3)
};

namespace asttooling {
class DerivableMatchCallback                
    : public clbind::Derivable&lt;clang::ast_matchers::MatchFinder::MatchCallback&gt; {  // (4)
  typedef clang::ast_matchers::MatchFinder::MatchCallback AlienBase;               // (5)
public:

  virtual void run(const clang::ast_matchers::MatchFinder::MatchResult &amp;Result) {  // (6)
    const clang::ast_matchers::MatchFinderMatchResult conv(Result);
    core::T_sp val =  translate::to_object&lt;const clang::ast_matchers::MatchFinderMatchResult &amp;&gt;::convert(conv);
    core::eval::funcall(asttooling::_sym_run, this-&gt;asSmartPtr(), val);
  }
  void default_run(const clang::ast_matchers::MatchFinderMatchResult &amp;Result) {    // (7)
    SIMPLE_ERROR(BF("Subclass must implement"));
  };

  virtual void onStartOfTranslationUnit() {                                        // (8)
    printf("%s:%d entered onStartOfTranslationUnit funcalling\n", __FILE__, __LINE__);
    core::eval::funcall(_sym_onStartOfTranslationUnit, this-&gt;asSmartPtr());
  }
  void default_onStartOfTranslationUnit() {
    printf("%s:%d entered default_onStartOfTranslationUnit\n", __FILE__, __LINE__);
    this-&gt;AlienBase::onStartOfTranslationUnit();
  }

  void describe() {                                                               // (9)
    printf("%s:%d Entered DerivableMatchCallback::describe()\n", __FILE__, __LINE__);
    printf("this=%p  typeid(this)@%p  typeid(this).name=%s\n", this, &amp;typeid(this), typeid(this).name());
    printf("dynamic_cast&lt;void*&gt;(this) = %p\n", dynamic_cast&lt;void *&gt;(this));
    printf("dynamic_cast&lt;core::T_O*&gt;(this) = %p\n", dynamic_cast&lt;core::T_O *&gt;(this));
    printf("typeid(dynamic_cast&lt;core::T_O&gt;*&gt;(this))@%p  typeid.name=%s\n", &amp;typeid(dynamic_cast&lt;core::T_O *&gt;(this)), typeid(dynamic_cast&lt;core::T_O *&gt;(this)).name());
    printf("dynamic_cast&lt;Derivable&lt;clang::ast_matchers::MatchFinder::MatchCallback&gt;*&gt;(this) = %p\n", dynamic_cast&lt;Derivable&lt;clang::ast_matchers::MatchFinder::MatchCallback&gt; *&gt;(this));
    printf("dynamic_cast&lt;DerivableMatchCallback*&gt;(this) = %p\n", dynamic_cast&lt;DerivableMatchCallback *&gt;(this));
    printf("alien pointer = %p\n", this-&gt;pointerToAlienWithin());
    printf("_Class: %s\n", _rep_(this-&gt;_Class).c_str());
    for (size_t i(0); i &lt; this-&gt;numberOfSlots(); ++i) {
      printf("_Slots[%lu]: %s\n", i, _rep_(this-&gt;instanceRef(i)).c_str());
    }
  }
  virtual ~DerivableMatchCallback() {                                            // (10)
    // Non trivial dtor  
  }
};
};
</pre>
</div>

<ol class="org-ol">
<li>A forward declaration of the DerivableMatchCallback class for the next piece GCInfo</li>
<li>A gctools::GCInfo template struct is used to tell the Clasp memory manager how to deal with this class.   The NeedsInitialization field tell the memory manager that the DerivableMatchCallback::initialize() function must be called after the object is allocated.  The NeedsFinalization field tells the memory manager that the destructor for this class needs to be registered with a finalizer.  NeedsFinalization is used for resources like streams and anything that needs cleanup when it is collected. The Policy tell the memory manager how the memory for this object is managed.
<ol class="org-ol">
<li>Policy = normal means the object is managed by the memory manager, it can be collected and it can be moved.</li>
<li>Policy = collectable_immobile means the object can be collected by the memory manager but it cannot be moved.</li>
<li>Policy = atomic means the object contains no internal pointers (such as strings or integer vectors) and so it can be placed in special memory that doesn't need to be scanned.</li>
<li>Policy = unmanaged means the object will not be automatically collected and it cannot be moved.  This is used in special cases like static vectors.</li>
</ol></li>
<li>Instances of DerivableMatchCallback cannot be moved or automatically collected. They need to be managed manually and carefully so that they do not leak memory.</li>
<li>The DerivableMatchCallback inherits from a special template class clbind::Derivable&lt;clang::ast_matchers::MatchFinder::MatchCallback&gt;. This makes it inherit from both the C++ class MatchCallback and the Clasp Instance_O class, which adds Common Lisp slots to the object.</li>
<li>The AlienBase type needs to be defined for derivable_class_ to function.</li>
<li>THe virtual void run(&#x2026;) {&#x2026;} method is defined by <code>clang::ast_matchers::MatchFinder::MatchCallback</code> and we need to overload it. The body of this method translates the argument(s) into Common Lisp types and then invokes a Common Lisp function <code>core::eval::funcall(asttooling::_sym_run, this-&gt;asSmartPtr(), val)</code> that the user will define in Common Lisp.</li>
<li>The void default_run(&#x2026;) method is a non virtual method that is exposed to Common Lisp. If a C++ base class defines the run method then defaul_run should call it.  If no C++ base class defines the run method then an error should be signalled and the user must provide a run function in Common Lisp.</li>
<li>In this example the <code>onStartOfTranslationUnit~/~default_onStartOfTranslationUnit</code> are another pair of functions that allow the user to overload an on-start-of-translation-unit method from Common Lisp.</li>
<li>In this example a <code>describe</code> method is provided to print internal information about a <code>DerivableMatchCallback</code> instance.</li>
<li>The <code>DerivableMatchCallback</code> class should have a destructor.</li>
</ol>

<p>
In the above example the <code>run~/~default_run</code> pair of methods demonstrate what you need to overload the <code>run</code> C++ method from Common Lisp.
</p>

<p>
In Common Lisp - to create a derived class one would use&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defclass count-match-callback (ast-tooling:match-callback) ()        ;; (1)
  (:metaclass core:derivable-cxx-class))

(core:defvirtual ast-tooling:run ((self count-match-callback) match)  ;; (2)
  (let* ((nodes (ast-tooling:nodes match))
	 (id-to-node-map (ast-tooling:idto-node-map nodes))
	 (node (gethash :whole id-to-node-map)))
    (advance-match-counter)))
</pre>
</div>

<ol class="org-ol">
<li>The derived class is defined using <code>defclass</code> inheriting from the exposed class and using the <code>:metaclass core:derivable-cxx-class</code>.</li>
<li>The <code>core:defvirtual</code> macro is used to overload the <code>asttooling:run</code> method. The overloaded method takes two arguments, the first argument is the instance <code>self</code> and the second argument was passed from the C++ <code>run</code> virtual method.</li>
</ol>
</div>
</div>
</div>



<div id="outline-container-org6dd4a95" class="outline-2">
<h2 id="org6dd4a95"><span class="section-number-2">7</span> Exposing Enums</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">
<pre class="src src-C++">
enum ColorEnum { red, green, blue  };

void printColor( ColorEnum color ) {
  switch (color) {
  case red:
      printf("red\n");
      break;
  case green:
      printf("green\n");
      break;
  case blue:
      printf("blue\n");
      break;
  }
}

// ...
// Then - to expose it...
//
PACKAGE_NICKNAME("HW");
NAMESPACE_PACKAGE_ASSOCIATION(hw,HWPkg,"HELLO-WORLD");

SYMBOL_EXPORT_SC_(HWPkg,STARcolorTranslatorSTAR);                              // (1)
CLBIND_TRANSLATE_SYMBOL_TO_ENUM(ColorEnum, hw::_sym_STARcolorTranslatorSTAR ); // (2)

namespace hw {
CL_EXPOSE
void hello_world_startup() {
  printf("Entered %s:%d:%s\n", __FILE__, __LINE__, __FUNCTION__ );
  using namespace clbind;
  package_ pkg(HWPkg);
  scope_&amp; s = pkg.scope();
  //
  // Other bindings
  //
  enum_&lt;ColorEnum&gt;(s,hw::_sym_STARcolorTranslatorSTAR)       // (3)
      .value("red",red)                                      // (4)
      .value("green",green)
      .value("blue",blue);
  s.def("printColor",&amp;printColor);                           // (5)
}
</pre>
</div>

<ol class="org-ol">
<li>Export the symbol HW:*COLOR-TRANSLATOR*.</li>
<li>Create a type translator that translates Common Lisp symbols into ColorEnum values and signals errors on illegal values.</li>
<li>Define the enum binding for ColorEnum and bind it to the symbol HW:*COLOR-TRANSLATOR*.</li>
<li>Define one enum value associating ColorEnum::red with the symbol 'HW:RED. The symbols for the enum values will be in the same package as the HW:*COLOR-TRANSLATOR*.</li>
<li>Expose a function that accepts ColorEnum values as the argument.</li>
</ol>


<p>
Then to use it from within clasp&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-lisp">COMMON-LISP-USER&gt; (hw:print-color 'hw:red)
red

COMMON-LISP-USER&gt; (hw:print-color 'hw:green)
green

COMMON-LISP-USER&gt; (hw:print-color 'hw:blue)
blue

COMMON-LISP-USER&gt; hw:*color-translator*

#&lt;SYMBOL-TO-ENUM-CONVERTER  :info *COLOR-TRANSLATOR* #&lt;entry 1 GREEN&gt; #&lt;entry 0 RED&gt; #&lt;entry 2 BLUE&gt;  &gt;
COMMON-LISP-USER&gt;
</pre>
</div>
</div>
</div>


<div id="outline-container-orgffc8a91" class="outline-2">
<h2 id="orgffc8a91"><span class="section-number-2">8</span> Translators</h2>
<div class="outline-text-2" id="text-8">
<p>
Translators are used to automatically convert C++ objects to Common Lisp objects and vice versa. This is a convenience functionality, allowing for easier interoperation. It is especially useful for small C++ classes and structs that are passed to and from functions and are meant to be created on the fly. Instead of exposing them and then creating and filling them from Common Lisp, it is often easier to write a translator, e.g. from a list, which makes it possible to pass a list as a parameter in place of the object. This list is then automatically converted to the respective C++ object by the translator.
</p>
</div>

<div id="outline-container-org3ce892d" class="outline-3">
<h3 id="org3ce892d"><span class="section-number-3">8.1</span> Translation from C++ objects to Common Lisp objects</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Translating from C++ to Common Lisp objects is done by specializing the templated struct <code>to_object</code> in the namespace <code>translate</code> to the type of the C++ object, with the static function member function <code>convert</code> of that struct taking an object of that type as a parameter and returning the Clasp Common Lisp Object.  The translator must appear in the C++ source code before any functions/methods are exposed that need to use it.  Translators are incorporated into the template code that clbind generates for each exposed function/method.
</p>


<div class="org-src-container">
<pre class="src src-C++">namespace translate
{
  template &lt;&gt;
  struct to_object&lt;std::pair&lt;int,int&gt;&gt;
  {
    static core::T_sp convert(std::pair&lt;int,int&gt; arg)
    {
       core::Cons_sp cons = core::Cons_O::create(core::Integer_O::create(arg.first),
						 core::Integer_O::create(arg.second));
       return cons;
    }
  };
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org647a4ab" class="outline-3">
<h3 id="org647a4ab"><span class="section-number-3">8.2</span> Translation from Common Lisp objects to C++ objects</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Translating from Common Lisp to C++ objects is done by specializing the templated struct <code>from_object</code> in the namespace <code>translate</code> to the C++ object type and providing a constructor that takes the Common Lisp object as a parameter and writes the result into an object called <code>_v</code> of the C++ object type:
</p>

<p>
The <code>DeclareType</code> typedef is necessary for the clbind template code to function.
</p>

<div class="org-src-container">
<pre class="src src-C++">namespace translate
{
  template &lt;&gt;
  struct from_object&lt;std::pair&lt;int,int&gt;&gt;
  {
    typedef std::pair&lt;int,int&gt; DeclareType;                             // (1)
    DeclareType _v;                                    
    from_object(core::T_sp obj)
    {
      if (obj.consp()) {                                                // (2)
	  this-&gt;_v = std::make_pair(core::clasp_to_int(CONS_CAR(obj)),  // (3)
				    core::clasp_to_int(CONS_CDR(obj)));
      }
      TYPE_ERROR(obj,cl::_sym_Cons_O);                                  // (4)
    }
  };
};
</pre>
</div>

<ol class="org-ol">
<li>DeclareType is used by clbind - define it to the from_object template type.</li>
<li>In this example we translate (cons &lt;number&gt; &lt;number&gt;) to std::pair&lt;int,int&gt;</li>
<li>We store the translated result in the <code>_v</code> field this is so that if the argument is used as a return value then the value can be recovered from here.</li>
<li>If the type of <code>obj</code> doesn't match what this translator handles then signal an appropriate type error telling the user what types are accepted.</li>
</ol>
</div>


<div id="outline-container-org2cc66f3" class="outline-4">
<h4 id="org2cc66f3"><span class="section-number-4">8.2.1</span> Advanced from_object translators</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
template &lt;&gt; struct from_object {&#x2026;} takes a second template argument that can have the value <code>std::true_type</code> or <code>std::false_type</code>. The default is <code>std::true_type</code> and
it means that the <code>_v</code> instance variable will be initialized by the from_object constructor using the Common Lisp value in the <code>T_sp</code> constructor argument.
<code>std::false_type</code> is subtle - it is used to express the <code>pureOutValue&lt;N&gt;</code> policy. <code>std::false_type</code> means that the from_object translator does not initialize its <code>_v</code> field
but the field can be passed by reference to a function, written in to and then the wrapper will take the result out and return it as a multiple return value.
</p>

<div class="org-src-container">
<pre class="src src-C++">template &lt;&gt;
struct from_object&lt;int&amp;,std::true_type&gt; {
  typedef int DeclareType;
  int _v;
  from_object(gctools::smart_ptr&lt;core::T_O&gt; vv) : _v(core::clasp_to_int(vv)) {}; // (1)
  ~from_object() { /* Non-trivial */ };
};

template &lt;&gt;
struct from_object&lt;int&amp;,std::false_type&gt; {
  typedef int DeclareType;
  int _v;
  from_object(gctools::smart_ptr&lt;core::T_O&gt; vv) {
    (void)vv;
    // Note - the _v field is NOT initialized!                    // (2)
  };
  ~from_object() {                                                // (3)
    // non-trivial dtor to keep _v around
  };
};

</pre>
</div>

<ol class="org-ol">
<li>In the first form of from_object the _v field is initialized using a Common Lisp value.</li>
<li>In the second form of the from_object translator the _v field is left uninitialized.</li>
<li>It's really important to define a non-trivial destructor or the _v field gets overwritten by the C++ compiler.</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-org7ff9b4d" class="outline-2">
<h2 id="org7ff9b4d"><span class="section-number-2">9</span> Policies</h2>
<div class="outline-text-2" id="text-9">
<p>
Policies tell clbind how to handle return values and C++ arguments.
</p>
</div>

<div id="outline-container-orga7625ea" class="outline-3">
<h3 id="orga7625ea"><span class="section-number-3">9.1</span> pureOutValue&lt;N&gt;</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Let's say you have a C++ function like so&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-lisp">
void addMul(int x, int y, int z, int&amp; sum, int&amp; product ) {
  sum = x + y + z;
  product = x * y * z;
}
</pre>
</div>

<p>
Common Lisp doesn't have a concept of "pass-by-reference" but it does have a powerful feature of multiple-return-values.
The <code>pureOutValue&lt;N&gt;</code> policy tells clbind that the C++ pass by reference values are to be used to return multiple values.
</p>

<div class="org-src-container">
<pre class="src src-C++">using namespace clbind;
package_ pkg("HELLO-WORLD",{"HW"},{});
pkg.scope.def( "addMul", &amp;addMul, pureOutValue&lt;3&gt;(), pureOutValue&lt;4&gt;() ); // 1
</pre>
</div>

<ol class="org-ol">
<li>The <code>pureOutValue&lt;3&gt;()</code> and <code>pureOutValue&lt;4&gt;()</code> arguments tell clbind that the third and fourth arguments to the <code>addMul</code> function are pass by reference.  The argument counting starts at 0.  <code>pureOutValue&lt;N&gt;()</code> further says that these values can be passed in as undefined and when the function returns the values in sum and product they should be returned in the first and second multiple-return values.</li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp">COMMON-LISP-USER&gt; (hw:add-mul 2 3 4)

9
24
</pre>
</div>

<p>
The function returns two values: 9 and 24.
</p>

<p>
Clbind knows that if the function returns a value using the normal C++ <code>return</code> instruction that that becomes the
first returned value and all other return values follow it.
</p>

<div class="org-src-container">
<pre class="src src-C++">int returnThreeValues(int&amp; second, int&amp; third)
{
  second = 2;
  third = 3;
  return 1;
}
//...
  s.def("returnThreeValues",&amp;returnThreeValues,
	clbind::pureOutValue&lt;0&gt;(),
	clbind::pureOutValue&lt;1&gt;());
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">COMMON-LISP-USER&gt; (multiple-value-bind (a b c) (hw:return-three-values) (list a b c))

(1 2 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-org35af480" class="outline-3">
<h3 id="org35af480"><span class="section-number-3">9.2</span> outValue&lt;N&gt;</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Let's say you have a C++ function like so&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-lisp">
void addMulRunning(int x, int y, int z, int&amp; sum, int&amp; product ) {
  sum = x + y + z + sum;
  product = x * y * z * product;
}
</pre>
</div>

<p>
In this case the <code>outValue&lt;N&gt;</code> policy tells clbind that values will be passed in to these arguments and multiple return values will be returned using these arguments.
</p>

<div class="org-src-container">
<pre class="src src-C++">using namespace clbind;
package_ pkg("TEACH",{},{});
pkg.scope.def( "addMulRunning", &amp;addMulRunning, outValue&lt;3&gt;(), outValue&lt;4&gt;() ); // 1
</pre>
</div>

<ol class="org-ol">
<li>The <code>outValue&lt;3&gt;()</code> and <code>outValue&lt;4&gt;()</code> arguments tell clbind that the third</li>
</ol>
<p>
and fourth arguments to the <code>addMulRunning</code> function are pass by reference.  The argument counting
starts at 0.  <code>outValue&lt;N&gt;()</code> further says that these values will be passed in to the function through these arguments
and when the function returns the values in sum and product they should be returned in the first
and second multiple-return values.
</p>

<div class="org-src-container">
<pre class="src src-lisp">COMMON-LISP-USER&gt; (multiple-value-bind (sum prod) (hw:add-mul-running 2 3 4 5 6)
		    (format t "Returned ~s~%" (list sum prod)))
Returned (14 144)
NIL
</pre>
</div>

<p>
Clbind knows that if the function returns a value using the normal C++ <code>return</code> instruction that that becomes the
first returned value and all other return values follow it.
</p>
</div>
</div>


<div id="outline-container-org9bdc578" class="outline-3">
<h3 id="org9bdc578"><span class="section-number-3">9.3</span> adopt&lt;n&gt;</h3>
<div class="outline-text-3" id="text-9-3">
<p>
adopt&lt;n&gt; is used to instruct clbind that a pointer to an object that is returned by a function is to be managed by Clasp's
memory manager.  The template argument for adopt can be "result" as in <code>adopt&lt;result&gt;</code> to indicate the
function return value pointer is to be adopted. The template argument can also be an integer 0&#x2026;N, as in <code>adopt&lt;0&gt;</code> to indicate that the first argument is a pointer that should be adopted by the memory manager. <code>adopt&lt;i&gt;</code> when i is an integer must be combined with <code>pureOutValue&lt;i&gt;</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org084cfe7" class="outline-2">
<h2 id="org084cfe7"><span class="section-number-2">10</span> Lispification</h2>
<div class="outline-text-2" id="text-10">
<p>
Lispification is a process used to convert strings in C++ code and C++ identifiers into Common Lisp hyphenated names.
</p>
</div>

<div id="outline-container-org2b8ded0" class="outline-3">
<h3 id="org2b8ded0"><span class="section-number-3">10.1</span> Camel case</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Camel case strings are converted to hyphenated names by inserting hyphens into the final name when there is a transition between a lower case character and an upper case character.
</p>

<p>
A few examples:
</p>

<ol class="org-ol">
<li>aCamelCaseName -&gt; a-camel-case-name</li>
<li>ANameWithANumber42 -&gt; aname-with-anumber42</li>
</ol>
</div>
</div>

<div id="outline-container-org06fd9ee" class="outline-3">
<h3 id="org06fd9ee"><span class="section-number-3">10.2</span> Underscores become hyphens</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Examples:
</p>

<ol class="org-ol">
<li>a_name_with_underscores -&gt; a-name-with-underscores</li>
<li>a_nameWithUnderscores -&gt; a-name-with-underscores</li>
</ol>

<p>
Underscores and camel case can be mixed.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<center><p>
<a href="sitemap.html">Sitemap</a> &#x2014; <a href="license.html">License</a>
</p>
</center>
</div>
</body>
</html>
